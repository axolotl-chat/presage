window.SIDEBAR_ITEMS = {"enum":[["CiphertextMessage",""],["CiphertextMessageType",""],["ContentHint",""],["Direction","Each Signal message can be considered to have exactly two participants, a sender and receiver."]],"fn":[["create_sender_key_distribution_message",""],["extract_decryption_error_message_from_serialized_content","For testing"],["group_decrypt",""],["group_encrypt",""],["initialize_alice_session_record",""],["initialize_bob_session_record",""],["message_decrypt",""],["message_decrypt_prekey",""],["message_decrypt_signal",""],["message_encrypt",""],["process_prekey",""],["process_prekey_bundle",""],["process_sender_key_distribution_message",""],["sealed_sender_decrypt","Decrypt a Sealed Sender message `ciphertext` in either the v1 or v2 format, validate its sender certificate, and then decrypt the inner message payload."],["sealed_sender_decrypt_to_usmc","Decrypt the payload of a sealed-sender message in either the v1 or v2 format."],["sealed_sender_encrypt","Encrypt the plaintext message `ptext`, generate an [`UnidentifiedSenderMessageContent`], then pass the result to [`sealed_sender_encrypt_from_usmc`]."],["sealed_sender_encrypt_from_usmc","This method implements the single-key single-recipient KEM described in this Signal blog post, a.k.a. Sealed Sender v1."],["sealed_sender_multi_recipient_encrypt","This method implements a single-key multi-recipient KEM as defined in Manuel Barbosa’s “Randomness Reuse: Extensions and Improvements”, a.k.a. Sealed Sender v2."],["sealed_sender_multi_recipient_fan_out","Split out the encoded message from [`sealed_sender_multi_recipient_encrypt`] into a sequence of individual encrypted [`UnidentifiedSenderMessageContent`]s. Note: this method is only used in testing."]],"mod":[["error",""]],"struct":[["AliceSignalProtocolParameters",""],["BobSignalProtocolParameters",""],["DecryptionErrorMessage",""],["DeviceId","The type used in memory to represent a device, i.e. a particular Signal client instance which represents some user."],["DisplayableFingerprint",""],["Fingerprint",""],["IdentityKey","A public key that represents the identity of a user."],["IdentityKeyPair","The private identity of a user."],["InMemIdentityKeyStore","Reference implementation of [traits::IdentityKeyStore]."],["InMemPreKeyStore","Reference implementation of [traits::PreKeyStore]."],["InMemSenderKeyStore","Reference implementation of [traits::SenderKeyStore]."],["InMemSessionStore","Reference implementation of [traits::SessionStore]."],["InMemSignalProtocolStore","Reference implementation of [traits::ProtocolStore]."],["InMemSignedPreKeyStore","Reference implementation of [traits::SignedPreKeyStore]."],["KeyPair",""],["PlaintextContent",""],["PreKeyBundle",""],["PreKeyId","A unique identifier selecting among this client’s known pre-keys."],["PreKeyRecord",""],["PreKeySignalMessage",""],["PrivateKey",""],["ProtocolAddress","Represents a unique Signal client instance as `(<user ID>, <device ID>)` pair."],["PublicKey",""],["ScannableFingerprint",""],["SealedSenderDecryptionResult",""],["SenderCertificate",""],["SenderKeyDistributionMessage",""],["SenderKeyMessage",""],["SenderKeyRecord",""],["ServerCertificate",""],["SessionRecord",""],["SignalMessage",""],["SignedPreKeyId","A unique identifier selecting among this client’s known signed pre-keys."],["SignedPreKeyRecord",""],["UnidentifiedSenderMessageContent",""]],"trait":[["IdentityKeyStore","Interface defining the identity store, which may be in-memory, on-disk, etc."],["PreKeyStore","Interface for storing pre-keys downloaded from a server."],["ProtocolStore","Mixes in all the store interfaces defined in this module."],["SenderKeyStore","Interface for storing sender key records, allowing multiple keys per user."],["SessionStore","Interface for a Signal client instance to store a session associated with another particular separate Signal client instance."],["SignedPreKeyStore","Interface for storing signed pre-keys downloaded from a server."]],"type":[["Context","Handle to FFI-provided context object."]]};